{"ast":null,"code":"class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.sessionId = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.messageHandlers = new Map();\n    this.connectionHandlers = new Map();\n    this.isConnecting = false;\n    this.autoReconnect = true;\n  }\n\n  // Initialize WebSocket connection\n  connect(sessionId = null) {\n    var _this$ws;\n    if (this.isConnecting || ((_this$ws = this.ws) === null || _this$ws === void 0 ? void 0 : _this$ws.readyState) === WebSocket.OPEN) {\n      return;\n    }\n    this.isConnecting = true;\n    this.sessionId = sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    const wsUrl = `ws://localhost:8000/ws/${this.sessionId}`;\n    try {\n      this.ws = new WebSocket(wsUrl);\n      this.setupEventHandlers();\n      console.log(`üîó Connecting to WebSocket: ${wsUrl}`);\n    } catch (error) {\n      console.error('‚ùå WebSocket connection error:', error);\n      this.isConnecting = false;\n      this.handleConnectionError(error);\n    }\n  }\n\n  // Setup WebSocket event handlers\n  setupEventHandlers() {\n    this.ws.onopen = () => {\n      console.log('‚úÖ WebSocket connected successfully');\n      this.isConnecting = false;\n      this.reconnectAttempts = 0;\n      this.notifyConnectionHandlers('connected');\n\n      // Send initial connection message\n      this.send({\n        type: 'connection',\n        data: {\n          session_id: this.sessionId,\n          client_type: 'web_ui',\n          timestamp: new Date().toISOString()\n        }\n      });\n    };\n    this.ws.onmessage = event => {\n      try {\n        const message = JSON.parse(event.data);\n        this.handleMessage(message);\n      } catch (error) {\n        console.error('‚ùå Error parsing WebSocket message:', error);\n      }\n    };\n    this.ws.onclose = event => {\n      console.log('üîå WebSocket disconnected:', event.code, event.reason);\n      this.isConnecting = false;\n      this.notifyConnectionHandlers('disconnected');\n      if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n        this.scheduleReconnect();\n      }\n    };\n    this.ws.onerror = error => {\n      console.error('‚ùå WebSocket error:', error);\n      this.handleConnectionError(error);\n    };\n  }\n\n  // Handle incoming messages\n  handleMessage(message) {\n    console.log('üì® Received message:', message);\n    const handler = this.messageHandlers.get(message.type);\n    if (handler) {\n      try {\n        handler(message.data);\n      } catch (error) {\n        console.error(`‚ùå Error in message handler for ${message.type}:`, error);\n      }\n    } else {\n      console.log(`‚ö†Ô∏è No handler found for message type: ${message.type}`);\n    }\n  }\n\n  // Send message to WebSocket\n  send(message) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      try {\n        const messageWithTimestamp = {\n          ...message,\n          timestamp: new Date().toISOString(),\n          session_id: this.sessionId\n        };\n        this.ws.send(JSON.stringify(messageWithTimestamp));\n        console.log('üì§ Sent message:', messageWithTimestamp);\n        return true;\n      } catch (error) {\n        console.error('‚ùå Error sending message:', error);\n        return false;\n      }\n    } else {\n      console.warn('‚ö†Ô∏è WebSocket not connected, cannot send message');\n      return false;\n    }\n  }\n\n  // Send audio data\n  sendAudio(audioData, metadata = {}) {\n    return this.send({\n      type: 'audio_data',\n      data: {\n        audio: audioData,\n        metadata: {\n          sample_rate: metadata.sample_rate || 24000,\n          channels: metadata.channels || 1,\n          timestamp: new Date().toISOString(),\n          ...metadata\n        }\n      }\n    });\n  }\n\n  // Send video frame\n  sendVideoFrame(videoFrame, metadata = {}) {\n    return this.send({\n      type: 'video_frame',\n      data: {\n        frame: videoFrame,\n        metadata: {\n          width: metadata.width || 640,\n          height: metadata.height || 480,\n          timestamp: new Date().toISOString(),\n          ...metadata\n        }\n      }\n    });\n  }\n\n  // Send transcription\n  sendTranscription(text, confidence = 1.0, metadata = {}) {\n    return this.send({\n      type: 'transcription',\n      data: {\n        text,\n        confidence,\n        timestamp: new Date().toISOString(),\n        ...metadata\n      }\n    });\n  }\n\n  // Send audio settings\n  sendAudioSettings(settings) {\n    return this.send({\n      type: 'audio_settings',\n      data: settings\n    });\n  }\n\n  // Send control commands\n  sendControl(command, data = {}) {\n    return this.send({\n      type: 'control',\n      data: {\n        command,\n        timestamp: new Date().toISOString(),\n        ...data\n      }\n    });\n  }\n\n  // Test connection with ping\n  ping() {\n    return this.send({\n      type: 'ping'\n    });\n  }\n\n  // Request status update\n  requestStatus() {\n    return this.send({\n      type: 'get_status'\n    });\n  }\n\n  // Start recording session\n  startRecording(settings = {}) {\n    return this.sendControl('start_recording', settings);\n  }\n\n  // Stop recording session\n  stopRecording() {\n    return this.sendControl('stop_recording');\n  }\n\n  // Start AI session\n  startAISession(settings = {}) {\n    return this.sendControl('start_ai_session', settings);\n  }\n\n  // Stop AI session\n  stopAISession() {\n    return this.sendControl('stop_ai_session');\n  }\n\n  // Register message handler\n  onMessage(type, handler) {\n    this.messageHandlers.set(type, handler);\n  }\n\n  // Register connection handler\n  onConnection(type, handler) {\n    if (!this.connectionHandlers.has(type)) {\n      this.connectionHandlers.set(type, []);\n    }\n    this.connectionHandlers.get(type).push(handler);\n  }\n\n  // Remove message handler\n  removeMessageHandler(type) {\n    this.messageHandlers.delete(type);\n  }\n\n  // Remove connection handler\n  removeConnectionHandler(type, handler) {\n    const handlers = this.connectionHandlers.get(type);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  // Notify connection handlers\n  notifyConnectionHandlers(status) {\n    const handlers = this.connectionHandlers.get(status);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(this.sessionId);\n        } catch (error) {\n          console.error('‚ùå Error in connection handler:', error);\n        }\n      });\n    }\n  }\n\n  // Schedule reconnection\n  scheduleReconnect() {\n    this.reconnectAttempts++;\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    console.log(`üîÑ Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);\n    setTimeout(() => {\n      var _this$ws2;\n      if (this.autoReconnect && ((_this$ws2 = this.ws) === null || _this$ws2 === void 0 ? void 0 : _this$ws2.readyState) !== WebSocket.OPEN) {\n        this.connect(this.sessionId);\n      }\n    }, delay);\n  }\n\n  // Handle connection errors\n  handleConnectionError(error) {\n    console.error('‚ùå WebSocket connection error:', error);\n    this.notifyConnectionHandlers('error');\n  }\n\n  // Disconnect WebSocket\n  disconnect() {\n    this.autoReconnect = false;\n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnecting');\n      this.ws = null;\n    }\n    this.isConnecting = false;\n    this.notifyConnectionHandlers('disconnected');\n  }\n\n  // Get connection status\n  getConnectionStatus() {\n    if (!this.ws) return 'disconnected';\n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'connected';\n      case WebSocket.CLOSING:\n        return 'closing';\n      case WebSocket.CLOSED:\n        return 'disconnected';\n      default:\n        return 'unknown';\n    }\n  }\n\n  // Check if connected\n  isConnected() {\n    var _this$ws3;\n    return ((_this$ws3 = this.ws) === null || _this$ws3 === void 0 ? void 0 : _this$ws3.readyState) === WebSocket.OPEN;\n  }\n\n  // Get session ID\n  getSessionId() {\n    return this.sessionId;\n  }\n\n  // Update auto-reconnect setting\n  setAutoReconnect(enabled) {\n    this.autoReconnect = enabled;\n  }\n}\n\n// Create singleton instance\nconst websocketService = new WebSocketService();\nexport default websocketService;","map":{"version":3,"names":["WebSocketService","constructor","ws","sessionId","reconnectAttempts","maxReconnectAttempts","reconnectDelay","messageHandlers","Map","connectionHandlers","isConnecting","autoReconnect","connect","_this$ws","readyState","WebSocket","OPEN","Date","now","Math","random","toString","substr","wsUrl","setupEventHandlers","console","log","error","handleConnectionError","onopen","notifyConnectionHandlers","send","type","data","session_id","client_type","timestamp","toISOString","onmessage","event","message","JSON","parse","handleMessage","onclose","code","reason","scheduleReconnect","onerror","handler","get","messageWithTimestamp","stringify","warn","sendAudio","audioData","metadata","audio","sample_rate","channels","sendVideoFrame","videoFrame","frame","width","height","sendTranscription","text","confidence","sendAudioSettings","settings","sendControl","command","ping","requestStatus","startRecording","stopRecording","startAISession","stopAISession","onMessage","set","onConnection","has","push","removeMessageHandler","delete","removeConnectionHandler","handlers","index","indexOf","splice","status","forEach","delay","pow","setTimeout","_this$ws2","disconnect","close","getConnectionStatus","CONNECTING","CLOSING","CLOSED","isConnected","_this$ws3","getSessionId","setAutoReconnect","enabled","websocketService"],"sources":["/Users/yueling/Monash/PeaceMaker/ui/src/services/websocketService.js"],"sourcesContent":["class WebSocketService {\n  constructor() {\n    this.ws = null;\n    this.sessionId = null;\n    this.reconnectAttempts = 0;\n    this.maxReconnectAttempts = 5;\n    this.reconnectDelay = 1000;\n    this.messageHandlers = new Map();\n    this.connectionHandlers = new Map();\n    this.isConnecting = false;\n    this.autoReconnect = true;\n  }\n\n  // Initialize WebSocket connection\n  connect(sessionId = null) {\n    if (this.isConnecting || this.ws?.readyState === WebSocket.OPEN) {\n      return;\n    }\n\n    this.isConnecting = true;\n    this.sessionId = sessionId || `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n    \n    const wsUrl = `ws://localhost:8000/ws/${this.sessionId}`;\n    \n    try {\n      this.ws = new WebSocket(wsUrl);\n      this.setupEventHandlers();\n      console.log(`üîó Connecting to WebSocket: ${wsUrl}`);\n    } catch (error) {\n      console.error('‚ùå WebSocket connection error:', error);\n      this.isConnecting = false;\n      this.handleConnectionError(error);\n    }\n  }\n\n  // Setup WebSocket event handlers\n  setupEventHandlers() {\n    this.ws.onopen = () => {\n      console.log('‚úÖ WebSocket connected successfully');\n      this.isConnecting = false;\n      this.reconnectAttempts = 0;\n      this.notifyConnectionHandlers('connected');\n      \n      // Send initial connection message\n      this.send({\n        type: 'connection',\n        data: {\n          session_id: this.sessionId,\n          client_type: 'web_ui',\n          timestamp: new Date().toISOString()\n        }\n      });\n    };\n\n    this.ws.onmessage = (event) => {\n      try {\n        const message = JSON.parse(event.data);\n        this.handleMessage(message);\n      } catch (error) {\n        console.error('‚ùå Error parsing WebSocket message:', error);\n      }\n    };\n\n    this.ws.onclose = (event) => {\n      console.log('üîå WebSocket disconnected:', event.code, event.reason);\n      this.isConnecting = false;\n      this.notifyConnectionHandlers('disconnected');\n      \n      if (this.autoReconnect && this.reconnectAttempts < this.maxReconnectAttempts) {\n        this.scheduleReconnect();\n      }\n    };\n\n    this.ws.onerror = (error) => {\n      console.error('‚ùå WebSocket error:', error);\n      this.handleConnectionError(error);\n    };\n  }\n\n  // Handle incoming messages\n  handleMessage(message) {\n    console.log('üì® Received message:', message);\n    \n    const handler = this.messageHandlers.get(message.type);\n    if (handler) {\n      try {\n        handler(message.data);\n      } catch (error) {\n        console.error(`‚ùå Error in message handler for ${message.type}:`, error);\n      }\n    } else {\n      console.log(`‚ö†Ô∏è No handler found for message type: ${message.type}`);\n    }\n  }\n\n  // Send message to WebSocket\n  send(message) {\n    if (this.ws && this.ws.readyState === WebSocket.OPEN) {\n      try {\n        const messageWithTimestamp = {\n          ...message,\n          timestamp: new Date().toISOString(),\n          session_id: this.sessionId\n        };\n        \n        this.ws.send(JSON.stringify(messageWithTimestamp));\n        console.log('üì§ Sent message:', messageWithTimestamp);\n        return true;\n      } catch (error) {\n        console.error('‚ùå Error sending message:', error);\n        return false;\n      }\n    } else {\n      console.warn('‚ö†Ô∏è WebSocket not connected, cannot send message');\n      return false;\n    }\n  }\n\n  // Send audio data\n  sendAudio(audioData, metadata = {}) {\n    return this.send({\n      type: 'audio_data',\n      data: {\n        audio: audioData,\n        metadata: {\n          sample_rate: metadata.sample_rate || 24000,\n          channels: metadata.channels || 1,\n          timestamp: new Date().toISOString(),\n          ...metadata\n        }\n      }\n    });\n  }\n\n  // Send video frame\n  sendVideoFrame(videoFrame, metadata = {}) {\n    return this.send({\n      type: 'video_frame',\n      data: {\n        frame: videoFrame,\n        metadata: {\n          width: metadata.width || 640,\n          height: metadata.height || 480,\n          timestamp: new Date().toISOString(),\n          ...metadata\n        }\n      }\n    });\n  }\n\n  // Send transcription\n  sendTranscription(text, confidence = 1.0, metadata = {}) {\n    return this.send({\n      type: 'transcription',\n      data: {\n        text,\n        confidence,\n        timestamp: new Date().toISOString(),\n        ...metadata\n      }\n    });\n  }\n\n  // Send audio settings\n  sendAudioSettings(settings) {\n    return this.send({\n      type: 'audio_settings',\n      data: settings\n    });\n  }\n\n  // Send control commands\n  sendControl(command, data = {}) {\n    return this.send({\n      type: 'control',\n      data: {\n        command,\n        timestamp: new Date().toISOString(),\n        ...data\n      }\n    });\n  }\n\n  // Test connection with ping\n  ping() {\n    return this.send({ type: 'ping' });\n  }\n\n  // Request status update\n  requestStatus() {\n    return this.send({ type: 'get_status' });\n  }\n\n  // Start recording session\n  startRecording(settings = {}) {\n    return this.sendControl('start_recording', settings);\n  }\n\n  // Stop recording session\n  stopRecording() {\n    return this.sendControl('stop_recording');\n  }\n\n  // Start AI session\n  startAISession(settings = {}) {\n    return this.sendControl('start_ai_session', settings);\n  }\n\n  // Stop AI session\n  stopAISession() {\n    return this.sendControl('stop_ai_session');\n  }\n\n  // Register message handler\n  onMessage(type, handler) {\n    this.messageHandlers.set(type, handler);\n  }\n\n  // Register connection handler\n  onConnection(type, handler) {\n    if (!this.connectionHandlers.has(type)) {\n      this.connectionHandlers.set(type, []);\n    }\n    this.connectionHandlers.get(type).push(handler);\n  }\n\n  // Remove message handler\n  removeMessageHandler(type) {\n    this.messageHandlers.delete(type);\n  }\n\n  // Remove connection handler\n  removeConnectionHandler(type, handler) {\n    const handlers = this.connectionHandlers.get(type);\n    if (handlers) {\n      const index = handlers.indexOf(handler);\n      if (index > -1) {\n        handlers.splice(index, 1);\n      }\n    }\n  }\n\n  // Notify connection handlers\n  notifyConnectionHandlers(status) {\n    const handlers = this.connectionHandlers.get(status);\n    if (handlers) {\n      handlers.forEach(handler => {\n        try {\n          handler(this.sessionId);\n        } catch (error) {\n          console.error('‚ùå Error in connection handler:', error);\n        }\n      });\n    }\n  }\n\n  // Schedule reconnection\n  scheduleReconnect() {\n    this.reconnectAttempts++;\n    const delay = this.reconnectDelay * Math.pow(2, this.reconnectAttempts - 1);\n    \n    console.log(`üîÑ Scheduling reconnection attempt ${this.reconnectAttempts} in ${delay}ms`);\n    \n    setTimeout(() => {\n      if (this.autoReconnect && this.ws?.readyState !== WebSocket.OPEN) {\n        this.connect(this.sessionId);\n      }\n    }, delay);\n  }\n\n  // Handle connection errors\n  handleConnectionError(error) {\n    console.error('‚ùå WebSocket connection error:', error);\n    this.notifyConnectionHandlers('error');\n  }\n\n  // Disconnect WebSocket\n  disconnect() {\n    this.autoReconnect = false;\n    \n    if (this.ws) {\n      this.ws.close(1000, 'Client disconnecting');\n      this.ws = null;\n    }\n    \n    this.isConnecting = false;\n    this.notifyConnectionHandlers('disconnected');\n  }\n\n  // Get connection status\n  getConnectionStatus() {\n    if (!this.ws) return 'disconnected';\n    \n    switch (this.ws.readyState) {\n      case WebSocket.CONNECTING:\n        return 'connecting';\n      case WebSocket.OPEN:\n        return 'connected';\n      case WebSocket.CLOSING:\n        return 'closing';\n      case WebSocket.CLOSED:\n        return 'disconnected';\n      default:\n        return 'unknown';\n    }\n  }\n\n  // Check if connected\n  isConnected() {\n    return this.ws?.readyState === WebSocket.OPEN;\n  }\n\n  // Get session ID\n  getSessionId() {\n    return this.sessionId;\n  }\n\n  // Update auto-reconnect setting\n  setAutoReconnect(enabled) {\n    this.autoReconnect = enabled;\n  }\n}\n\n// Create singleton instance\nconst websocketService = new WebSocketService();\n\nexport default websocketService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}