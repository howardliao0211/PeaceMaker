{"ast":null,"code":"class AudioService {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.analyser = null;\n    this.microphone = null;\n    this.isRecording = false;\n    this.audioChunks = [];\n    this.stream = null;\n    this.onAudioData = null;\n    this.onTranscription = null;\n    this.recordingInterval = null;\n    this.sampleRate = 24000;\n    this.channels = 1;\n    this.vadThreshold = 0.2;\n    this.echoCancellation = true;\n    this.noiseSuppression = true;\n  }\n\n  // Initialize audio context and get user permission\n  async initialize() {\n    try {\n      // Request microphone access\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: this.sampleRate,\n          channelCount: this.channels,\n          echoCancellation: this.echoCancellation,\n          noiseSuppression: this.noiseSuppression,\n          autoGainControl: true\n        },\n        video: false\n      });\n\n      // Create audio context\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: this.sampleRate\n      });\n\n      // Create analyser for voice activity detection\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 2048;\n      this.analyser.smoothingTimeConstant = 0.8;\n\n      // Connect microphone to analyser\n      this.microphone = this.audioContext.createMediaStreamSource(this.stream);\n      this.microphone.connect(this.analyser);\n      console.log('‚úÖ Audio service initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error initializing audio service:', error);\n      throw error;\n    }\n  }\n\n  // Start recording audio\n  async startRecording() {\n    if (this.isRecording) {\n      console.warn('‚ö†Ô∏è Already recording');\n      return false;\n    }\n    if (!this.stream) {\n      await this.initialize();\n    }\n    try {\n      this.isRecording = true;\n      this.audioChunks = [];\n\n      // Create media recorder\n      this.mediaRecorder = new MediaRecorder(this.stream, {\n        mimeType: 'audio/webm;codecs=opus',\n        audioBitsPerSecond: 128000\n      });\n\n      // Handle recorded data\n      this.mediaRecorder.ondataavailable = event => {\n        if (event.data.size > 0) {\n          this.audioChunks.push(event.data);\n          this.processAudioChunk(event.data);\n        }\n      };\n\n      // Start recording\n      this.mediaRecorder.start(100); // Collect data every 100ms\n\n      // Start real-time audio analysis\n      this.startAudioAnalysis();\n      console.log('üéôÔ∏è Audio recording started');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error starting audio recording:', error);\n      this.isRecording = false;\n      throw error;\n    }\n  }\n\n  // Stop recording audio\n  stopRecording() {\n    if (!this.isRecording) {\n      console.warn('‚ö†Ô∏è Not recording');\n      return false;\n    }\n    try {\n      this.isRecording = false;\n      if (this.mediaRecorder) {\n        this.mediaRecorder.stop();\n        this.mediaRecorder = null;\n      }\n      if (this.recordingInterval) {\n        clearInterval(this.recordingInterval);\n        this.recordingInterval = null;\n      }\n      console.log('üõë Audio recording stopped');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error stopping audio recording:', error);\n      throw error;\n    }\n  }\n\n  // Process audio chunk in real-time\n  async processAudioChunk(audioBlob) {\n    try {\n      // Convert blob to array buffer\n      const arrayBuffer = await audioBlob.arrayBuffer();\n\n      // Convert to audio buffer\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n\n      // Extract audio data\n      const audioData = audioBuffer.getChannelData(0);\n\n      // Check voice activity\n      if (this.detectVoiceActivity(audioData)) {\n        // Send audio data to WebSocket if callback is set\n        if (this.onAudioData) {\n          this.onAudioData(audioData, {\n            sample_rate: this.sampleRate,\n            channels: this.channels,\n            timestamp: new Date().toISOString()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error processing audio chunk:', error);\n    }\n  }\n\n  // Start real-time audio analysis\n  startAudioAnalysis() {\n    if (this.recordingInterval) {\n      clearInterval(this.recordingInterval);\n    }\n    this.recordingInterval = setInterval(() => {\n      if (this.isRecording && this.analyser) {\n        this.analyzeAudio();\n      }\n    }, 50); // Analyze every 50ms\n  }\n\n  // Analyze current audio for voice activity\n  analyzeAudio() {\n    try {\n      const bufferLength = this.analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      this.analyser.getByteFrequencyData(dataArray);\n\n      // Calculate average volume\n      let sum = 0;\n      for (let i = 0; i < bufferLength; i++) {\n        sum += dataArray[i];\n      }\n      const averageVolume = sum / bufferLength;\n\n      // Check if volume exceeds threshold (voice activity detection)\n      if (averageVolume > this.vadThreshold * 255) {\n        // Voice detected - could trigger transcription or other actions\n        if (this.onTranscription) {\n          this.onTranscription({\n            volume: averageVolume / 255,\n            timestamp: new Date().toISOString()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error analyzing audio:', error);\n    }\n  }\n\n  // Detect voice activity in audio data\n  detectVoiceActivity(audioData) {\n    try {\n      // Calculate RMS (Root Mean Square) for volume detection\n      let sum = 0;\n      for (let i = 0; i < audioData.length; i++) {\n        sum += audioData[i] * audioData[i];\n      }\n      const rms = Math.sqrt(sum / audioData.length);\n\n      // Return true if volume exceeds threshold\n      return rms > this.vadThreshold;\n    } catch (error) {\n      console.error('‚ùå Error detecting voice activity:', error);\n      return false;\n    }\n  }\n\n  // Update audio settings\n  updateSettings(settings) {\n    if (settings.sample_rate) {\n      this.sampleRate = settings.sample_rate;\n    }\n    if (settings.vad_threshold !== undefined) {\n      this.vadThreshold = settings.vad_threshold;\n    }\n    if (settings.echo_cancellation !== undefined) {\n      this.echoCancellation = settings.echo_cancellation;\n    }\n    if (settings.noise_suppression !== undefined) {\n      this.noiseSuppression = settings.noiseSuppression;\n    }\n    console.log('‚öôÔ∏è Audio settings updated:', settings);\n  }\n\n  // Get current audio settings\n  getSettings() {\n    return {\n      sample_rate: this.sampleRate,\n      channels: this.channels,\n      vad_threshold: this.vadThreshold,\n      echo_cancellation: this.echoCancellation,\n      noise_suppression: this.noiseSuppression\n    };\n  }\n\n  // Set callback for audio data\n  setAudioDataCallback(callback) {\n    this.onAudioData = callback;\n  }\n\n  // Set callback for transcription events\n  setTranscriptionCallback(callback) {\n    this.onTranscription = callback;\n  }\n\n  // Get recording status\n  getRecordingStatus() {\n    return {\n      isRecording: this.isRecording,\n      hasStream: !!this.stream,\n      hasAudioContext: !!this.audioContext,\n      sampleRate: this.sampleRate,\n      channels: this.channels\n    };\n  }\n\n  // Clean up resources\n  cleanup() {\n    try {\n      this.stopRecording();\n      if (this.stream) {\n        this.stream.getTracks().forEach(track => track.stop());\n        this.stream = null;\n      }\n      if (this.audioContext) {\n        this.audioContext.close();\n        this.audioContext = null;\n      }\n      this.microphone = null;\n      this.analyser = null;\n      this.audioChunks = [];\n      console.log('üßπ Audio service cleaned up');\n    } catch (error) {\n      console.error('‚ùå Error cleaning up audio service:', error);\n    }\n  }\n\n  // Get available audio devices\n  async getAudioDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'audioinput');\n    } catch (error) {\n      console.error('‚ùå Error getting audio devices:', error);\n      return [];\n    }\n  }\n\n  // Switch to different audio device\n  async switchAudioDevice(deviceId) {\n    try {\n      if (this.stream) {\n        this.stream.getTracks().forEach(track => track.stop());\n      }\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: {\n            exact: deviceId\n          },\n          sampleRate: this.sampleRate,\n          channelCount: this.channels,\n          echoCancellation: this.echoCancellation,\n          noiseSuppression: this.noiseSuppression,\n          autoGainControl: true\n        }\n      });\n      if (this.audioContext && this.microphone) {\n        this.microphone.disconnect();\n        this.microphone = this.audioContext.createMediaStreamSource(this.stream);\n        this.microphone.connect(this.analyser);\n      }\n      console.log('üîÑ Switched to audio device:', deviceId);\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error switching audio device:', error);\n      throw error;\n    }\n  }\n}\n\n// Create singleton instance\nconst audioService = new AudioService();\nexport default audioService;","map":{"version":3,"names":["AudioService","constructor","mediaRecorder","audioContext","analyser","microphone","isRecording","audioChunks","stream","onAudioData","onTranscription","recordingInterval","sampleRate","channels","vadThreshold","echoCancellation","noiseSuppression","initialize","navigator","mediaDevices","getUserMedia","audio","channelCount","autoGainControl","video","window","AudioContext","webkitAudioContext","createAnalyser","fftSize","smoothingTimeConstant","createMediaStreamSource","connect","console","log","error","startRecording","warn","MediaRecorder","mimeType","audioBitsPerSecond","ondataavailable","event","data","size","push","processAudioChunk","start","startAudioAnalysis","stopRecording","stop","clearInterval","audioBlob","arrayBuffer","audioBuffer","decodeAudioData","audioData","getChannelData","detectVoiceActivity","sample_rate","timestamp","Date","toISOString","setInterval","analyzeAudio","bufferLength","frequencyBinCount","dataArray","Uint8Array","getByteFrequencyData","sum","i","averageVolume","volume","length","rms","Math","sqrt","updateSettings","settings","vad_threshold","undefined","echo_cancellation","noise_suppression","getSettings","setAudioDataCallback","callback","setTranscriptionCallback","getRecordingStatus","hasStream","hasAudioContext","cleanup","getTracks","forEach","track","close","getAudioDevices","devices","enumerateDevices","filter","device","kind","switchAudioDevice","deviceId","exact","disconnect","audioService"],"sources":["/Users/yueling/Monash/PeaceMaker/ui/src/services/audioService.js"],"sourcesContent":["class AudioService {\n  constructor() {\n    this.mediaRecorder = null;\n    this.audioContext = null;\n    this.analyser = null;\n    this.microphone = null;\n    this.isRecording = false;\n    this.audioChunks = [];\n    this.stream = null;\n    this.onAudioData = null;\n    this.onTranscription = null;\n    this.recordingInterval = null;\n    this.sampleRate = 24000;\n    this.channels = 1;\n    this.vadThreshold = 0.2;\n    this.echoCancellation = true;\n    this.noiseSuppression = true;\n  }\n\n  // Initialize audio context and get user permission\n  async initialize() {\n    try {\n      // Request microphone access\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          sampleRate: this.sampleRate,\n          channelCount: this.channels,\n          echoCancellation: this.echoCancellation,\n          noiseSuppression: this.noiseSuppression,\n          autoGainControl: true\n        },\n        video: false\n      });\n\n      // Create audio context\n      this.audioContext = new (window.AudioContext || window.webkitAudioContext)({\n        sampleRate: this.sampleRate\n      });\n\n      // Create analyser for voice activity detection\n      this.analyser = this.audioContext.createAnalyser();\n      this.analyser.fftSize = 2048;\n      this.analyser.smoothingTimeConstant = 0.8;\n\n      // Connect microphone to analyser\n      this.microphone = this.audioContext.createMediaStreamSource(this.stream);\n      this.microphone.connect(this.analyser);\n\n      console.log('‚úÖ Audio service initialized successfully');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error initializing audio service:', error);\n      throw error;\n    }\n  }\n\n  // Start recording audio\n  async startRecording() {\n    if (this.isRecording) {\n      console.warn('‚ö†Ô∏è Already recording');\n      return false;\n    }\n\n    if (!this.stream) {\n      await this.initialize();\n    }\n\n    try {\n      this.isRecording = true;\n      this.audioChunks = [];\n\n      // Create media recorder\n      this.mediaRecorder = new MediaRecorder(this.stream, {\n        mimeType: 'audio/webm;codecs=opus',\n        audioBitsPerSecond: 128000\n      });\n\n      // Handle recorded data\n      this.mediaRecorder.ondataavailable = (event) => {\n        if (event.data.size > 0) {\n          this.audioChunks.push(event.data);\n          this.processAudioChunk(event.data);\n        }\n      };\n\n      // Start recording\n      this.mediaRecorder.start(100); // Collect data every 100ms\n\n      // Start real-time audio analysis\n      this.startAudioAnalysis();\n\n      console.log('üéôÔ∏è Audio recording started');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error starting audio recording:', error);\n      this.isRecording = false;\n      throw error;\n    }\n  }\n\n  // Stop recording audio\n  stopRecording() {\n    if (!this.isRecording) {\n      console.warn('‚ö†Ô∏è Not recording');\n      return false;\n    }\n\n    try {\n      this.isRecording = false;\n\n      if (this.mediaRecorder) {\n        this.mediaRecorder.stop();\n        this.mediaRecorder = null;\n      }\n\n      if (this.recordingInterval) {\n        clearInterval(this.recordingInterval);\n        this.recordingInterval = null;\n      }\n\n      console.log('üõë Audio recording stopped');\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error stopping audio recording:', error);\n      throw error;\n    }\n  }\n\n  // Process audio chunk in real-time\n  async processAudioChunk(audioBlob) {\n    try {\n      // Convert blob to array buffer\n      const arrayBuffer = await audioBlob.arrayBuffer();\n      \n      // Convert to audio buffer\n      const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);\n      \n      // Extract audio data\n      const audioData = audioBuffer.getChannelData(0);\n      \n      // Check voice activity\n      if (this.detectVoiceActivity(audioData)) {\n        // Send audio data to WebSocket if callback is set\n        if (this.onAudioData) {\n          this.onAudioData(audioData, {\n            sample_rate: this.sampleRate,\n            channels: this.channels,\n            timestamp: new Date().toISOString()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error processing audio chunk:', error);\n    }\n  }\n\n  // Start real-time audio analysis\n  startAudioAnalysis() {\n    if (this.recordingInterval) {\n      clearInterval(this.recordingInterval);\n    }\n\n    this.recordingInterval = setInterval(() => {\n      if (this.isRecording && this.analyser) {\n        this.analyzeAudio();\n      }\n    }, 50); // Analyze every 50ms\n  }\n\n  // Analyze current audio for voice activity\n  analyzeAudio() {\n    try {\n      const bufferLength = this.analyser.frequencyBinCount;\n      const dataArray = new Uint8Array(bufferLength);\n      this.analyser.getByteFrequencyData(dataArray);\n\n      // Calculate average volume\n      let sum = 0;\n      for (let i = 0; i < bufferLength; i++) {\n        sum += dataArray[i];\n      }\n      const averageVolume = sum / bufferLength;\n\n      // Check if volume exceeds threshold (voice activity detection)\n      if (averageVolume > this.vadThreshold * 255) {\n        // Voice detected - could trigger transcription or other actions\n        if (this.onTranscription) {\n          this.onTranscription({\n            volume: averageVolume / 255,\n            timestamp: new Date().toISOString()\n          });\n        }\n      }\n    } catch (error) {\n      console.error('‚ùå Error analyzing audio:', error);\n    }\n  }\n\n  // Detect voice activity in audio data\n  detectVoiceActivity(audioData) {\n    try {\n      // Calculate RMS (Root Mean Square) for volume detection\n      let sum = 0;\n      for (let i = 0; i < audioData.length; i++) {\n        sum += audioData[i] * audioData[i];\n      }\n      const rms = Math.sqrt(sum / audioData.length);\n      \n      // Return true if volume exceeds threshold\n      return rms > this.vadThreshold;\n    } catch (error) {\n      console.error('‚ùå Error detecting voice activity:', error);\n      return false;\n    }\n  }\n\n  // Update audio settings\n  updateSettings(settings) {\n    if (settings.sample_rate) {\n      this.sampleRate = settings.sample_rate;\n    }\n    if (settings.vad_threshold !== undefined) {\n      this.vadThreshold = settings.vad_threshold;\n    }\n    if (settings.echo_cancellation !== undefined) {\n      this.echoCancellation = settings.echo_cancellation;\n    }\n    if (settings.noise_suppression !== undefined) {\n      this.noiseSuppression = settings.noiseSuppression;\n    }\n\n    console.log('‚öôÔ∏è Audio settings updated:', settings);\n  }\n\n  // Get current audio settings\n  getSettings() {\n    return {\n      sample_rate: this.sampleRate,\n      channels: this.channels,\n      vad_threshold: this.vadThreshold,\n      echo_cancellation: this.echoCancellation,\n      noise_suppression: this.noiseSuppression\n    };\n  }\n\n  // Set callback for audio data\n  setAudioDataCallback(callback) {\n    this.onAudioData = callback;\n  }\n\n  // Set callback for transcription events\n  setTranscriptionCallback(callback) {\n    this.onTranscription = callback;\n  }\n\n  // Get recording status\n  getRecordingStatus() {\n    return {\n      isRecording: this.isRecording,\n      hasStream: !!this.stream,\n      hasAudioContext: !!this.audioContext,\n      sampleRate: this.sampleRate,\n      channels: this.channels\n    };\n  }\n\n  // Clean up resources\n  cleanup() {\n    try {\n      this.stopRecording();\n      \n      if (this.stream) {\n        this.stream.getTracks().forEach(track => track.stop());\n        this.stream = null;\n      }\n      \n      if (this.audioContext) {\n        this.audioContext.close();\n        this.audioContext = null;\n      }\n      \n      this.microphone = null;\n      this.analyser = null;\n      this.audioChunks = [];\n      \n      console.log('üßπ Audio service cleaned up');\n    } catch (error) {\n      console.error('‚ùå Error cleaning up audio service:', error);\n    }\n  }\n\n  // Get available audio devices\n  async getAudioDevices() {\n    try {\n      const devices = await navigator.mediaDevices.enumerateDevices();\n      return devices.filter(device => device.kind === 'audioinput');\n    } catch (error) {\n      console.error('‚ùå Error getting audio devices:', error);\n      return [];\n    }\n  }\n\n  // Switch to different audio device\n  async switchAudioDevice(deviceId) {\n    try {\n      if (this.stream) {\n        this.stream.getTracks().forEach(track => track.stop());\n      }\n\n      this.stream = await navigator.mediaDevices.getUserMedia({\n        audio: {\n          deviceId: { exact: deviceId },\n          sampleRate: this.sampleRate,\n          channelCount: this.channels,\n          echoCancellation: this.echoCancellation,\n          noiseSuppression: this.noiseSuppression,\n          autoGainControl: true\n        }\n      });\n\n      if (this.audioContext && this.microphone) {\n        this.microphone.disconnect();\n        this.microphone = this.audioContext.createMediaStreamSource(this.stream);\n        this.microphone.connect(this.analyser);\n      }\n\n      console.log('üîÑ Switched to audio device:', deviceId);\n      return true;\n    } catch (error) {\n      console.error('‚ùå Error switching audio device:', error);\n      throw error;\n    }\n  }\n}\n\n// Create singleton instance\nconst audioService = new AudioService();\n\nexport default audioService;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}